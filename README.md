# CS-320-Software-Test-Automation-Test


How can I test my software to make sure it works and is safe? It might be difficult work to check that code works properly and is secure. So far I have just done code testing for this course, and it wasn't enough in several circumstances. Before taking this course, I had no idea how much work was required. By being true to the specifications and creating thorough tests that result in a high percentage of coverage, I can guarantee that my code is safe and fully functioning. As a result, I was able to ensure at least 90% coverage in my class assignment's software by repeatedly testing it. Assuring the code's functionality required mostly adhering to the requirements, and guaranteeing the code's security required performing rigorous tests based on the criteria.

 How can I understand what a program's users want and build it in? When figuring out how to meet a user's requirements, I examine their comments and then parse them into components that are either compatible or incompatible with the software in question. Limits on word count and submission of blank forms are two good examples. The first restriction concerned names; they must not be blank or less than 10 characters. After reading that, I added an if statement to the code that would handle either possible error. This is a very simple method of converting a requirement into a program, since it just turns the need into a necessary condition. Sometimes there are murkier criteria that need additional investigation. In another course, we were assigned a software that would, at the user's discretion, sum the timestamps of two different clocks. That was broken down into a program in great detail, but not like this one, since although you had the broad need, it wasn't as easy as throwing an illegal argument exception.
 
 What should my strategy be while creating software? I could improve my methodology while creating software. I like to review the requirements papers or, if that isn't possible, the interview transcripts, and make a requirements checklist. Next, if necessary, I dissect these criteria into a list of items that will be required to carry out the task at hand, and then I do the same for the necessary procedures. After compiling a number of checklists, I get into developing the necessary code. After I get the code to run, I go back over it and optimize it as much as possible. So far, this technique has served me well in my studies, but I see that I may benefit from adopting a broader and perhaps even more perceptive strategy.
